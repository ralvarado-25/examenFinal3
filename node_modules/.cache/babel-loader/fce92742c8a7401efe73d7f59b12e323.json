{"ast":null,"code":"import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, i as _set, b as _objectWithoutProperties } from '../_rollupPluginBabelHelpers-74ba0139.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/utils.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\n\nvar MaskedDynamic = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedDynamic, _Masked);\n\n  var _super = _createSuper(MaskedDynamic);\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\r\n    @param {Object} opts\r\n  */\n\n\n  function MaskedDynamic(opts) {\n    var _this;\n\n    _classCallCheck(this, MaskedDynamic);\n\n    _this = _super.call(this, Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    _this.currentMask = null;\n    return _this;\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedDynamic, [{\n    key: \"_update\",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedDynamic.prototype), \"_update\", this).call(this, opts);\n\n      if ('mask' in opts) {\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {\n          return createMask(m);\n        }) : [];\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var details = this._applyDispatch(ch, flags);\n\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendChar(ch, flags));\n      }\n\n      return details;\n    }\n  }, {\n    key: \"_applyDispatch\",\n    value: function _applyDispatch() {\n      var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n      var inputValue = this.rawInputValue;\n      var insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system\n      flags._beforeTailState._rawInputValue : inputValue;\n      var tailValue = inputValue.slice(insertValue.length);\n      var prevMask = this.currentMask;\n      var details = new ChangeDetails();\n      var prevMaskState = prevMask && prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n      this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch\n\n      if (this.currentMask) {\n        if (this.currentMask !== prevMask) {\n          // if mask changed reapply input\n          this.currentMask.reset();\n\n          if (insertValue) {\n            // $FlowFixMe - it's ok, we don't change current mask above\n            var d = this.currentMask.append(insertValue, {\n              raw: true\n            });\n            details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n          }\n\n          if (tailValue) {\n            // $FlowFixMe - it's ok, we don't change current mask above\n            details.tailShift += this.currentMask.append(tailValue, {\n              raw: true,\n              tail: true\n            }).tailShift;\n          }\n        } else {\n          // Dispatch can do something bad with state, so\n          // restore prev mask state\n          this.currentMask.state = prevMaskState;\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      var details = this._applyDispatch.apply(this, arguments);\n\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendPlaceholder());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doDispatch\",\n    value: function doDispatch(appended) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.dispatch(appended, this, flags);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate() {\n      var _get2, _this$currentMask;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedDynamic.prototype), \"doValidate\", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask = this.currentMask).doValidate.apply(_this$currentMask, args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.currentMask) this.currentMask.reset();\n      this.compiledMasks.forEach(function (m) {\n        return m.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.value : '';\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"value\", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.unmaskedValue : '';\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.typedValue : '';\n    } // probably typedValue should not be used with dynamic\n    ,\n    set: function set(value) {\n      var unmaskedValue = String(value); // double check it\n\n      if (this.currentMask) {\n        this.currentMask.typedValue = value;\n        unmaskedValue = this.currentMask.unmaskedValue;\n      }\n\n      this.unmaskedValue = unmaskedValue;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return !!this.currentMask && this.currentMask.isComplete;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var details = new ChangeDetails();\n\n      if (this.currentMask) {\n        var _this$currentMask2;\n\n        details.aggregate((_this$currentMask2 = this.currentMask).remove.apply(_this$currentMask2, arguments)) // update with dispatch\n        .aggregate(this._applyDispatch());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), \"state\", this), {\n        _rawInputValue: this.rawInputValue,\n        compiledMasks: this.compiledMasks.map(function (m) {\n          return m.state;\n        }),\n        currentMaskRef: this.currentMask,\n        currentMask: this.currentMask && this.currentMask.state\n      });\n    },\n    set: function set(state) {\n      var compiledMasks = state.compiledMasks,\n          currentMaskRef = state.currentMaskRef,\n          currentMask = state.currentMask,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this.compiledMasks.forEach(function (m, mi) {\n        return m.state = compiledMasks[mi];\n      });\n\n      if (currentMaskRef != null) {\n        this.currentMask = currentMaskRef;\n        this.currentMask.state = currentMask;\n      }\n\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"state\", maskedState, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var _this$currentMask3;\n\n      return this.currentMask ? (_this$currentMask3 = this.currentMask).extractInput.apply(_this$currentMask3, arguments) : '';\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this$currentMask4, _get3;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.currentMask ? (_this$currentMask4 = this.currentMask).extractTail.apply(_this$currentMask4, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic.prototype), \"extractTail\", this)).call.apply(_get3, [this].concat(args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.currentMask) this.currentMask.doCommit();\n\n      _get(_getPrototypeOf(MaskedDynamic.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos() {\n      var _this$currentMask5, _get4;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.currentMask ? (_this$currentMask5 = this.currentMask).nearestInputPos.apply(_this$currentMask5, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic.prototype), \"nearestInputPos\", this)).call.apply(_get4, [this].concat(args));\n    }\n  }, {\n    key: \"overwrite\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), \"overwrite\", this);\n    },\n    set: function set(overwrite) {\n      console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }]);\n\n  return MaskedDynamic;\n}(Masked);\n\nMaskedDynamic.DEFAULTS = {\n  dispatch: function dispatch(appended, masked, flags) {\n    if (!masked.compiledMasks.length) return;\n    var inputValue = masked.rawInputValue; // simulate input\n\n    var inputs = masked.compiledMasks.map(function (m, index) {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, flags);\n      var weight = m.rawInputValue.length;\n      return {\n        weight: weight,\n        index: index\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort(function (i1, i2) {\n      return i2.weight - i1.weight;\n    });\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport default MaskedDynamic;","map":{"version":3,"sources":["C:/Users/raula/Downloads/final/react-hotel-reservation-system-main/node_modules/imask/esm/masked/dynamic.js"],"names":["d","_inherits","e","_createSuper","a","_classCallCheck","_","_createClass","g","_get","h","_getPrototypeOf","i","_set","b","_objectWithoutProperties","ChangeDetails","createMask","Masked","IMask","_excluded","MaskedDynamic","_Masked","_super","opts","_this","call","Object","assign","DEFAULTS","currentMask","key","value","_update","prototype","compiledMasks","Array","isArray","mask","map","m","_appendCharRaw","ch","flags","arguments","length","undefined","details","_applyDispatch","aggregate","_appendChar","appended","prevValueBeforeTail","tail","_beforeTailState","_value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","prevMask","prevMaskState","state","doDispatch","reset","append","raw","tailShift","inserted","_appendPlaceholder","apply","dispatch","doValidate","_get2","_this$currentMask","_len","args","_key","concat","forEach","get","set","unmaskedValue","typedValue","String","isComplete","remove","_this$currentMask2","currentMaskRef","maskedState","mi","extractInput","_this$currentMask3","extractTail","_this$currentMask4","_get3","_len2","_key2","doCommit","nearestInputPos","_this$currentMask5","_get4","_len3","_key3","overwrite","console","warn","masked","inputs","index","weight","sort","i1","i2"],"mappings":"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","sourcesContent":["import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, i as _set, b as _objectWithoutProperties } from '../_rollupPluginBabelHelpers-74ba0139.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/utils.js';\nimport '../core/continuous-tail-details.js';\n\nvar _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"];\n\n/** Dynamic mask for choosing apropriate mask in run-time */\nvar MaskedDynamic = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedDynamic, _Masked);\n\n  var _super = _createSuper(MaskedDynamic);\n\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\r\n    @param {Object} opts\r\n  */\n  function MaskedDynamic(opts) {\n    var _this;\n\n    _classCallCheck(this, MaskedDynamic);\n\n    _this = _super.call(this, Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    _this.currentMask = null;\n    return _this;\n  }\n  /**\r\n    @override\r\n  */\n\n\n  _createClass(MaskedDynamic, [{\n    key: \"_update\",\n    value: function _update(opts) {\n      _get(_getPrototypeOf(MaskedDynamic.prototype), \"_update\", this).call(this, opts);\n\n      if ('mask' in opts) {\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {\n          return createMask(m);\n        }) : [];\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var details = this._applyDispatch(ch, flags);\n\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendChar(ch, flags));\n      }\n\n      return details;\n    }\n  }, {\n    key: \"_applyDispatch\",\n    value: function _applyDispatch() {\n      var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n      var inputValue = this.rawInputValue;\n      var insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system\n      flags._beforeTailState._rawInputValue : inputValue;\n      var tailValue = inputValue.slice(insertValue.length);\n      var prevMask = this.currentMask;\n      var details = new ChangeDetails();\n      var prevMaskState = prevMask && prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n      this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch\n\n      if (this.currentMask) {\n        if (this.currentMask !== prevMask) {\n          // if mask changed reapply input\n          this.currentMask.reset();\n\n          if (insertValue) {\n            // $FlowFixMe - it's ok, we don't change current mask above\n            var d = this.currentMask.append(insertValue, {\n              raw: true\n            });\n            details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n          }\n\n          if (tailValue) {\n            // $FlowFixMe - it's ok, we don't change current mask above\n            details.tailShift += this.currentMask.append(tailValue, {\n              raw: true,\n              tail: true\n            }).tailShift;\n          }\n        } else {\n          // Dispatch can do something bad with state, so\n          // restore prev mask state\n          this.currentMask.state = prevMaskState;\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      var details = this._applyDispatch.apply(this, arguments);\n\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendPlaceholder());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doDispatch\",\n    value: function doDispatch(appended) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.dispatch(appended, this, flags);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate() {\n      var _get2, _this$currentMask;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(MaskedDynamic.prototype), \"doValidate\", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask = this.currentMask).doValidate.apply(_this$currentMask, args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.currentMask) this.currentMask.reset();\n      this.compiledMasks.forEach(function (m) {\n        return m.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.value : '';\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"value\", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.unmaskedValue : '';\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.typedValue : '';\n    } // probably typedValue should not be used with dynamic\n    ,\n    set: function set(value) {\n      var unmaskedValue = String(value); // double check it\n\n      if (this.currentMask) {\n        this.currentMask.typedValue = value;\n        unmaskedValue = this.currentMask.unmaskedValue;\n      }\n\n      this.unmaskedValue = unmaskedValue;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return !!this.currentMask && this.currentMask.isComplete;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var details = new ChangeDetails();\n\n      if (this.currentMask) {\n        var _this$currentMask2;\n\n        details.aggregate((_this$currentMask2 = this.currentMask).remove.apply(_this$currentMask2, arguments)) // update with dispatch\n        .aggregate(this._applyDispatch());\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedDynamic.prototype), \"state\", this), {\n        _rawInputValue: this.rawInputValue,\n        compiledMasks: this.compiledMasks.map(function (m) {\n          return m.state;\n        }),\n        currentMaskRef: this.currentMask,\n        currentMask: this.currentMask && this.currentMask.state\n      });\n    },\n    set: function set(state) {\n      var compiledMasks = state.compiledMasks,\n          currentMaskRef = state.currentMaskRef,\n          currentMask = state.currentMask,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this.compiledMasks.forEach(function (m, mi) {\n        return m.state = compiledMasks[mi];\n      });\n\n      if (currentMaskRef != null) {\n        this.currentMask = currentMaskRef;\n        this.currentMask.state = currentMask;\n      }\n\n      _set(_getPrototypeOf(MaskedDynamic.prototype), \"state\", maskedState, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var _this$currentMask3;\n\n      return this.currentMask ? (_this$currentMask3 = this.currentMask).extractInput.apply(_this$currentMask3, arguments) : '';\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this$currentMask4, _get3;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.currentMask ? (_this$currentMask4 = this.currentMask).extractTail.apply(_this$currentMask4, args) : (_get3 = _get(_getPrototypeOf(MaskedDynamic.prototype), \"extractTail\", this)).call.apply(_get3, [this].concat(args));\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.currentMask) this.currentMask.doCommit();\n\n      _get(_getPrototypeOf(MaskedDynamic.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos() {\n      var _this$currentMask5, _get4;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.currentMask ? (_this$currentMask5 = this.currentMask).nearestInputPos.apply(_this$currentMask5, args) : (_get4 = _get(_getPrototypeOf(MaskedDynamic.prototype), \"nearestInputPos\", this)).call.apply(_get4, [this].concat(args));\n    }\n  }, {\n    key: \"overwrite\",\n    get: function get() {\n      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf(MaskedDynamic.prototype), \"overwrite\", this);\n    },\n    set: function set(overwrite) {\n      console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }]);\n\n  return MaskedDynamic;\n}(Masked);\nMaskedDynamic.DEFAULTS = {\n  dispatch: function dispatch(appended, masked, flags) {\n    if (!masked.compiledMasks.length) return;\n    var inputValue = masked.rawInputValue; // simulate input\n\n    var inputs = masked.compiledMasks.map(function (m, index) {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, flags);\n      var weight = m.rawInputValue.length;\n      return {\n        weight: weight,\n        index: index\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort(function (i1, i2) {\n      return i2.weight - i1.weight;\n    });\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport default MaskedDynamic;\n"]},"metadata":{},"sourceType":"module"}