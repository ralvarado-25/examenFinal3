{"ast":null,"code":"import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-74ba0139.js';\nimport { DIRECTION, forceDirection } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"_blocks\"];\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\n\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  var _super = _createSuper(MaskedPattern);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern); // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n\n        var _isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          _isInput = false;\n        }\n\n        var def = _isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, flags);\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE; // TODO refactor - extract alignblock\n\n      var beginBlockData = this._mapPosToBlock(cursorPos) || {\n        index: 0,\n        offset: 0\n      };\n      var beginBlockOffset = beginBlockData.offset,\n          beginBlockIndex = beginBlockData.index;\n      var beginBlock = this._blocks[beginBlockIndex];\n      if (!beginBlock) return cursorPos;\n      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it\n\n      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {\n        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));\n      }\n\n      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;\n      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)\n\n      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;\n      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;\n\n      if (direction === DIRECTION.NONE) {\n        // NONE direction used to calculate start input position if no chars were removed\n        // FOR NONE:\n        // -\n        // input|any\n        // ->\n        //  any|input\n        // <-\n        //  filled-input|any\n        // check if first block at left is input\n        if (searchBlockIndex > 0) {\n          var blockIndexAtLeft = searchBlockIndex - 1;\n          var blockAtLeft = this._blocks[blockIndexAtLeft];\n          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input\n\n          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {\n            return this._blockStartPos(searchBlockIndex);\n          }\n        } // ->\n\n\n        var firstInputAtRight = searchBlockIndex;\n\n        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {\n          var blockAtRight = this._blocks[bi];\n\n          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);\n\n          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {\n            return this._blockStartPos(bi) + _blockInputPos;\n          }\n        } // <-\n        // find first non-fixed symbol\n\n\n        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {\n          var _block3 = this._blocks[_bi];\n\n          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {\n            return this._blockStartPos(_bi) + _block3.value.length;\n          }\n        }\n\n        return cursorPos;\n      }\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // -\n        //  any|filled-input\n        // <-\n        //  any|first not empty is not-len-aligned\n        //  not-0-aligned|any\n        // ->\n        //  any|not-len-aligned or end\n        // check if first block at right is filled input\n        var firstFilledBlockIndexAtRight;\n\n        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {\n          if (this._blocks[_bi2].value) {\n            firstFilledBlockIndexAtRight = _bi2;\n            break;\n          }\n        }\n\n        if (firstFilledBlockIndexAtRight != null) {\n          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];\n\n          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);\n\n          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {\n            // filled block is input\n            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;\n          }\n        } // <-\n        // find this vars\n\n\n        var firstFilledInputBlockIndex = -1;\n        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs\n\n        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {\n          var _block4 = this._blocks[_bi3];\n\n          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);\n\n          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;\n\n          if (_blockInputPos4 !== 0) {\n            if (_blockInputPos4 !== _block4.value.length) {\n              // aligned inside block - return immediately\n              return this._blockStartPos(_bi3) + _blockInputPos4;\n            } else {\n              // found filled\n              firstFilledInputBlockIndex = _bi3;\n              break;\n            }\n          }\n        }\n\n        if (direction === DIRECTION.LEFT) {\n          // try find first empty input before start searching position only when not forced\n          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {\n            var _block5 = this._blocks[_bi4];\n\n            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);\n\n            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;\n\n            if (blockAlignedPos > cursorPos) break; // if block is not lazy input\n\n            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;\n          }\n        } // process overflow\n\n\n        if (firstFilledInputBlockIndex >= 0) {\n          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;\n        } // for lazy if has aligned left inside fixed and has came to the start - use start position\n\n\n        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {\n          return 0;\n        }\n\n        if (firstEmptyInputBlockIndex != null) {\n          return this._blockStartPos(firstEmptyInputBlockIndex);\n        } // find first input\n\n\n        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {\n          var _block6 = this._blocks[_bi5];\n\n          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {\n            return this._blockStartPos(_bi5) + _blockInputPos6;\n          }\n        }\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // ->\n        //  any|not-len-aligned and filled\n        //  any|not-len-aligned\n        // <-\n        //  not-0-aligned or start|any\n        var firstInputBlockAlignedIndex;\n        var firstInputBlockAlignedPos;\n\n        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {\n          var _block7 = this._blocks[_bi6];\n\n          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);\n\n          if (_blockInputPos7 !== _block7.value.length) {\n            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;\n            firstInputBlockAlignedIndex = _bi6;\n            break;\n          }\n        }\n\n        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {\n          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {\n            var _block8 = this._blocks[_bi7];\n\n            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);\n\n            if (_blockInputPos8 !== _block8.value.length) {\n              return this._blockStartPos(_bi7) + _blockInputPos8;\n            }\n          }\n\n          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;\n        }\n\n        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {\n          var _block9 = this._blocks[_bi8];\n\n          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);\n\n          if (_blockInputPos9 !== 0) {\n            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;\n\n            if (alignedPos >= cursorPos) return alignedPos;\n            break;\n          }\n        }\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\n\nfunction isInput(block) {\n  if (!block) return false;\n  var value = block.value;\n  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;\n}\n\nIMask.MaskedPattern = MaskedPattern;\nexport default MaskedPattern;","map":{"version":3,"sources":["C:/Users/raula/Downloads/final/react-hotel-reservation-system-main/node_modules/imask/esm/masked/pattern.js"],"names":["d","_inherits","e","_createSuper","a","_classCallCheck","_","_createClass","g","_get","h","_getPrototypeOf","b","_objectWithoutProperties","i","_set","DIRECTION","forceDirection","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","createMask","IMask","_excluded","MaskedPattern","_Masked","_super","opts","arguments","length","undefined","definitions","Object","assign","call","DEFAULTS","key","value","_update","prototype","_rebuildMask","_this","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","blocks","_ret","p","slice","bNames","keys","filter","bName","indexOf","sort","maskedBlock","parent","lazy","placeholderChar","overwrite","push","char","_isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","get","map","state","set","maskedState","forEach","bi","reset","every","isComplete","doCommit","reduce","str","unmaskedValue","appendTail","tail","aggregate","_appendPlaceholder","_appendCharRaw","ch","flags","blockIter","_mapPosToBlock","details","index","_block","blockDetails","_appendChar","skip","rawInserted","extractTail","_this2","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","_this3","startBlockIter","startBlockIndex","endBlockIndex","args","bDetails","apply","_value","inserted","pos","accVal","_block2","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","beginBlockData","beginBlockOffset","beginBlockIndex","beginBlock","beginBlockCursorPos","cursorAtRight","cursorAtLeft","searchBlockIndex","blockIndexAtLeft","blockAtLeft","blockInputPos","firstInputAtRight","blockAtRight","_blockInputPos","_bi","_block3","_blockInputPos2","LEFT","FORCE_LEFT","firstFilledBlockIndexAtRight","_bi2","filledBlock","_blockInputPos3","RIGHT","firstFilledInputBlockIndex","firstEmptyInputBlockIndex","_bi3","_block4","_blockInputPos4","_bi4","Math","min","_block5","_blockInputPos5","blockAlignedPos","isInput","_bi5","_block6","_blockInputPos6","FORCE_RIGHT","firstInputBlockAlignedIndex","firstInputBlockAlignedPos","_bi6","_block7","_blockInputPos7","_bi7","_block8","_blockInputPos8","_bi8","_block9","_blockInputPos9","alignedPos","name","maskedBlocks","_this4","indices","gi","InputDefinition","FixedDefinition","block"],"mappings":"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","sourcesContent":["import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-74ba0139.js';\nimport { DIRECTION, forceDirection } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nvar _excluded = [\"_blocks\"];\n\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  var _super = _createSuper(MaskedPattern);\n\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern);\n\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n\n        var _isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          _isInput = false;\n        }\n\n        var def = _isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, flags);\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      // TODO refactor - extract alignblock\n      var beginBlockData = this._mapPosToBlock(cursorPos) || {\n        index: 0,\n        offset: 0\n      };\n      var beginBlockOffset = beginBlockData.offset,\n          beginBlockIndex = beginBlockData.index;\n      var beginBlock = this._blocks[beginBlockIndex];\n      if (!beginBlock) return cursorPos;\n      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it\n\n      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {\n        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));\n      }\n\n      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;\n      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)\n\n      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;\n      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;\n\n      if (direction === DIRECTION.NONE) {\n        // NONE direction used to calculate start input position if no chars were removed\n        // FOR NONE:\n        // -\n        // input|any\n        // ->\n        //  any|input\n        // <-\n        //  filled-input|any\n        // check if first block at left is input\n        if (searchBlockIndex > 0) {\n          var blockIndexAtLeft = searchBlockIndex - 1;\n          var blockAtLeft = this._blocks[blockIndexAtLeft];\n          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input\n\n          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {\n            return this._blockStartPos(searchBlockIndex);\n          }\n        } // ->\n\n\n        var firstInputAtRight = searchBlockIndex;\n\n        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {\n          var blockAtRight = this._blocks[bi];\n\n          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);\n\n          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {\n            return this._blockStartPos(bi) + _blockInputPos;\n          }\n        } // <-\n        // find first non-fixed symbol\n\n\n        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {\n          var _block3 = this._blocks[_bi];\n\n          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {\n            return this._blockStartPos(_bi) + _block3.value.length;\n          }\n        }\n\n        return cursorPos;\n      }\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // -\n        //  any|filled-input\n        // <-\n        //  any|first not empty is not-len-aligned\n        //  not-0-aligned|any\n        // ->\n        //  any|not-len-aligned or end\n        // check if first block at right is filled input\n        var firstFilledBlockIndexAtRight;\n\n        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {\n          if (this._blocks[_bi2].value) {\n            firstFilledBlockIndexAtRight = _bi2;\n            break;\n          }\n        }\n\n        if (firstFilledBlockIndexAtRight != null) {\n          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];\n\n          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);\n\n          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {\n            // filled block is input\n            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;\n          }\n        } // <-\n        // find this vars\n\n\n        var firstFilledInputBlockIndex = -1;\n        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs\n\n        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {\n          var _block4 = this._blocks[_bi3];\n\n          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);\n\n          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;\n\n          if (_blockInputPos4 !== 0) {\n            if (_blockInputPos4 !== _block4.value.length) {\n              // aligned inside block - return immediately\n              return this._blockStartPos(_bi3) + _blockInputPos4;\n            } else {\n              // found filled\n              firstFilledInputBlockIndex = _bi3;\n              break;\n            }\n          }\n        }\n\n        if (direction === DIRECTION.LEFT) {\n          // try find first empty input before start searching position only when not forced\n          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {\n            var _block5 = this._blocks[_bi4];\n\n            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);\n\n            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;\n\n            if (blockAlignedPos > cursorPos) break; // if block is not lazy input\n\n            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;\n          }\n        } // process overflow\n\n\n        if (firstFilledInputBlockIndex >= 0) {\n          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;\n        } // for lazy if has aligned left inside fixed and has came to the start - use start position\n\n\n        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {\n          return 0;\n        }\n\n        if (firstEmptyInputBlockIndex != null) {\n          return this._blockStartPos(firstEmptyInputBlockIndex);\n        } // find first input\n\n\n        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {\n          var _block6 = this._blocks[_bi5];\n\n          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {\n            return this._blockStartPos(_bi5) + _blockInputPos6;\n          }\n        }\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // ->\n        //  any|not-len-aligned and filled\n        //  any|not-len-aligned\n        // <-\n        //  not-0-aligned or start|any\n        var firstInputBlockAlignedIndex;\n        var firstInputBlockAlignedPos;\n\n        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {\n          var _block7 = this._blocks[_bi6];\n\n          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);\n\n          if (_blockInputPos7 !== _block7.value.length) {\n            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;\n            firstInputBlockAlignedIndex = _bi6;\n            break;\n          }\n        }\n\n        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {\n          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {\n            var _block8 = this._blocks[_bi7];\n\n            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);\n\n            if (_blockInputPos8 !== _block8.value.length) {\n              return this._blockStartPos(_bi7) + _blockInputPos8;\n            }\n          }\n\n          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;\n        }\n\n        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {\n          var _block9 = this._blocks[_bi8];\n\n          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);\n\n          if (_blockInputPos9 !== 0) {\n            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;\n\n            if (alignedPos >= cursorPos) return alignedPos;\n            break;\n          }\n        }\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\n\nfunction isInput(block) {\n  if (!block) return false;\n  var value = block.value;\n  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;\n}\n\nIMask.MaskedPattern = MaskedPattern;\n\nexport default MaskedPattern;\n"]},"metadata":{},"sourceType":"module"}