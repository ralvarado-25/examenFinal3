{"ast":null,"code":"import { _ as _createClass, a as _classCallCheck } from '../_rollupPluginBabelHelpers-74ba0139.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n/** Supported mask type */\n\n/** Provides common masking stuff */\n\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\r\n      Sets new options\r\n      @protected\r\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n    /** Resets value */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n    /** Resolve new value */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n    /** Finds nearest input position in direction */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n\n      var details = this._appendCharRaw(this.doPrepare(ch, flags), flags);\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite) {\n            consistentTail = checkTail.state;\n            checkTail.shiftBefore(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags && flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\r\n      Prepares string before mask processing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\r\n      Validates if value is acceptable\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\r\n      Does additional processing in the end of editing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var startChangePos = this.nearestInputPos(start, removeDirection);\n      var changeDetails = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n      return changeDetails;\n    }\n  }]);\n\n  return Masked;\n}();\n\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\nexport default Masked;","map":{"version":3,"sources":["C:/Users/raula/Downloads/final/react-hotel-reservation-system-main/node_modules/imask/esm/masked/base.js"],"names":["_","_createClass","a","_classCallCheck","ChangeDetails","ContinuousTailDetails","isString","IMask","Masked","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","key","value","updateOptions","keys","length","withValueRefresh","bind","get","set","state","reset","resolve","append","input","doCommit","doParse","doFormat","extractInput","raw","nearestInputPos","cursorPos","direction","fromPos","arguments","undefined","toPos","slice","extractTail","appendTail","tail","String","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","flags","checkTail","consistentState","details","doPrepare","consistentTail","appended","doValidate","beforeTailState","overwrite","shiftBefore","tailDetails","toString","_appendPlaceholder","str","Error","_beforeTailState","ci","aggregate","tailShift","remove","fn","_refreshing","rawInput","rawInputValue","ret","indexOf","runIsolated","_isolated","prepare","validate","parent","commit","format","parse","splice","start","deleteCount","removeDirection","tailPos","startChangePos","changeDetails","v"],"mappings":"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","sourcesContent":["import { _ as _createClass, a as _classCallCheck } from '../_rollupPluginBabelHelpers-74ba0139.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Provides common masking stuff */\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\r\n      Sets new options\r\n      @protected\r\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n    /** Resets value */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n    /** Resolve new value */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n    /** Finds nearest input position in direction */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n\n      var details = this._appendCharRaw(this.doPrepare(ch, flags), flags);\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite) {\n            consistentTail = checkTail.state;\n            checkTail.shiftBefore(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags && flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\r\n      Prepares string before mask processing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\r\n      Validates if value is acceptable\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\r\n      Does additional processing in the end of editing\r\n      @protected\r\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var startChangePos = this.nearestInputPos(start, removeDirection);\n      var changeDetails = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n      return changeDetails;\n    }\n  }]);\n\n  return Masked;\n}();\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\n\nexport default Masked;\n"]},"metadata":{},"sourceType":"module"}